* TODO Intel microcode
#+begin_src  bash
sudo pacman -S intel-ucode # if AMD amd-ucode
#+end_src

* Package need by .dotfiles
#+begin_src shell
  sudo pacman -S less wget exa stow gpg emacs ranger fzf rofi rofi-emoji rofi-calc rofi-pass feh man-db unzip pass pass-otp xclip dmenu thunderbird aspell aspell-en aspell-fr zathura
#+end_src

- Using =exa= instead of =ls=.
- Password manager =pass= looks for passwords in ="$XDG_DATA_HOME"/pass= directory.
- Ranger - =ranger=, =fzf=, =locate=
- Password manager - =pass=, =pass-otp=, =xclip,= =dmenu=
- PDF viewer - =zathura=, =poppler= (engine), =zathura-pdf-poppler=

  
* Themes
#+begin_src  shell
  sudo pacman picom gnome-themes-extra kvantum papirus-icon-theme lxappearance qt5ct feh
#+end_src

* Polybar
Install polybar:
#+begin_src shell
  sudo pacman -S polybar
#+end_src

* Yay
[[https://github.com/Jguer/yay][Yet Another Yogurt]] (Yay) - An AUR Helper Written in Go

The initial installation of Yay can be done by cloning the PKGBUILD and building with makepkg /(Before you begin, make sure you have the base-devel package group installed)/:
#+begin_src shell
  pacman -S --needed git base-devel
  git clone https://aur.archlinux.org/yay.git
  cd yay
  makepkg -si
#+end_src

* TODO Firefox
Starting with Firefox 68, you can make all the Firefox interfaces and even other websites respect dark themes, irrespective of the system GTK theme and Firefox theme. To do this, set ui.systemUsesDarkTheme to 1 in about:config [13]. 

* TODO Remove file (if exist)
#+begin_src bash
  rm ~/.bash_profile ~/.bashrc
#+end_src

* Install color scirpts
#+begin_src bash
  cd ./shell-color-scripts && make clean install
#+end_src

* Install startship promt
#+begin_src bash
  curl -sS https://starship.rs/install.sh | sh
#+end_src

* Package to install for i3 vm
#+begin_src bash
sudo pacman -S xorg-xinit xorg-server i3-wm i3status
cp /etc/X11/xinit/xinitrc ~/.xinitrc
#+end_src

* TODO remote some lines at bottom
#+begin_src bash
  echo 'exec i3' >> ~/.xinitrc
#+end_src

* Show which comman has been executed
#+begin_src bash
  set -e
#+end_src

#+begin_src bash :tangle no
function insall_stow() {
    is_exist=`stow -V`
    if [ $is_exist -ne 0 ]
    then
	pacman -S stow
    fi
}
#+end_src

* Check if script runs as root
#+begin_src bash
function isRoot() {
    if [[ $(id -u) -ne 0 ]]
    then
	echo "Please run as root"
	exit 1
    fi
}
#+end_src

* TODO Fonts
:LOGBOOK:
- State "TODO"       from              [2023-12-10 Sun 12:15]
:END:

On Arch, the noto fonts for "everything" are split into:

noto-fonts for Roman, Greek, Cyrillic and probably some other alphabets, along with ASCII art nonsense and numbers and punctuation and stuff and I think some rudimentary Japanese and Chinese(?);
noto-fonts-emoji for emoji;
noto-fonts-cjk for Chinese, Japanese, and Korean characters (all of them); and
noto-fonts-extra for god knows what, I haven't looked.
With those four installed, you should always have an arbitrary character render properly. 

#+begin_src bash
  echo "Setting up Noto Emoji font..."
#+end_src

Install  noto-fonts-emoji package:
#+begin_src  shell
  pacman -S noto-fonts-emoji --needed
#+end_src

#+begin_src shell
  pacman -S powerline-fonts ttf-fira-code ttf-linux-libertine libertinus-font --needed
#+end_src
In my personel conf i use =ttf-linux-libertine= as "serif" family font.
=ttf-linux-libertine= - Serif (Libertine) and Sans Serif (Biolinum) OpenType fonts with large Unicode coverage.

=libertinus-font= - Fonts based on Linux Libertine/Biolinum, with extended math support.
=ttf-joypixels= - For emoji
=otf-font-awesome=, =ttf-font-awesome= - Fontawesome


#+begin_src shell
  echo "Recommended system font: inconsolata regular (ttf-inconsolata or powerline-fonts)"
#+end_src

Add font config to /etc/fonts/conf.d/01-notosans.conf:
#+begin_src shell :tangle no
  echo "<?xml version="1.0"?>
  <!DOCTYPE fontconfig SYSTEM "fonts.dtd">
  <fontconfig>
   <alias>
     <family>sans-serif</family>
     <prefer>
       <family>Noto Sans</family>
       <family>Noto Color Emoji</family>
       <family>Noto Emoji</family>
       <family>DejaVu Sans</family>
     </prefer> 
   </alias>

   <alias>
     <family>serif</family>
     <prefer>
       <family>Noto Serif</family>
       <family>Noto Color Emoji</family>
       <family>Noto Emoji</family>
       <family>DejaVu Serif</family>
     </prefer>
   </alias>

   <alias>
    <family>monospace</family>
    <prefer>
      <family>Noto Mono</family>
      <family>Noto Color Emoji</family>
      <family>Noto Emoji</family>
      <family>DejaVu Sans Mono</family>
     </prefer>
   </alias>
  </fontconfig>

  " > /etc/fonts/local.conf
#+end_src

Update font cache via fc-cache:
#+begin_src shell
  fc-cache -f
#+end_src

#+begin_src shell :tangle no
  echo "Noto Emoji Font installed! You may need to restart applications like chrome. If chrome displays no symbols or no letters, your default font contains emojis."
  echo "consider inconsolata regular"
#+end_src

* Touchpad and Keyboard Conf
** Touchpad
Arch supplies default configuration files in =/usr/share/X11/xorg.conf.d/=, and no extra configuration is necessary for most setups. But the =/etc/X11/xorg.conf.d/= directory stores host-specific configuration. 

#+begin_quote
Using .conf files

The /etc/X11/xorg.conf.d/ directory stores host-specific configuration. You are free to add configuration files there, but they must have a .conf suffix: the files are read in ASCII order, and by convention their names start with XX- (two digits and a hyphen, so that for example 10 is read before 20). These files are parsed by the X server upon startup and are treated like part of the traditional xorg.conf configuration file. Note that on conflicting configuration, the file read last will be processed. For this reason, the most generic configuration files should be ordered first by name. The configuration entries in the xorg.conf file are processed at the end. 

https://wiki.archlinux.org/title/Xorg
#+end_quote

xorg.conf is parsed by the X server at start-up. To apply changes, restart X.

#+begin_src :tangle /etc/X11/xorg.conf.d/30-touchpad.conf
Section "InputClass"
    Identifier "SYNA7DB5:00 06CB:CD40 Touchpad"
    Driver "libinput"
    Option "Tapping" "1"
    Option "NaturalScrolling" "1"
EndSection
#+end_src

=SYNA7DB5:00 06CB:CD40 Touchpad= is the name of device obtained using following command provided by the =xorg-input= package:
#+begin_src shell
  xinput list
#+end_src

/We can also use =libinput list-devices= command to list all devices and their respective features supported by libinput./
https://wiki.archlinux.org/title/Libinput

** Keyboard Conf
#+begin_src  :tangle /etc/X11/xorg.conf.d/90-custom-kbd.conf
"Section "InputClass"
    Identifier "keyboard defaults"
    MatchIsKeyboard "on"

    # Option "XKbOptions" "ctrl:swapcaps"
    Option "XKbOptions" "ctrl:nocaps"
EndSection
#+end_src

* Bluetooth
=Bluetooth= is a standard for the short-range wireless interconnection of cellular phones, computers, and other electronic devices. In Linux, the canonical implementation of the Bluetooth protocol stack is =BlueZ=.

1. Install the =bluez= package, providing the Bluetooth protocol stack.
2. Install the =bluez-utils= package, providing the bluetoothctl utility. Alternatively install =bluez-utils-compat=  (AUR Package) to additionally have the deprecated BlueZ tools.
3. The generic Bluetooth driver is the =btusb= kernel module. Check whether that module is loaded. If it is not, then load the module.
4. Start/enable =bluetooth.service=.

#+begin_src shell
  sudo pacman -S bluez bluez-utils
#+end_src

By default the Bluetooth daemon will only give out =bnep0= devices to users that are a member of the =lp= group. Make sure to add your user to that group if you intend to connect to a Bluetooth tether. You can change the group that is required in the file =/usr/share/dbus-1/system.d/bluetooth.conf=: 
#+begin_src shell
  sudo usermod -aG lp vts
#+end_src

** Pair Bluetooth Devices
Start the =bluetoothctl= interactive command:
1. (optional) Select a default controller with ~select MAC_address~.
2. (optional) Enter ~power on~ to turn on the controller on. It is on by default
3. Enter ~devices~ to get the MAC address of the device with which to pair.
   3.1. (optional) Enter device discovery mode with ~scan on~ command if device is not yet on the above list.
   3.2. Turn the agent on with  ~agent on~ or choose a specific agent: if you press tab twice after agent you should see a list of available agents. 
   A bluetooth agent is what manages the Bluetooth 'pairing code'. It can either respond to a 'pairing code' coming in, or can send one out. The default-agent should be appropriate in most cases.
6. Enter ~pair MAC_address~ to do the pairing.
7. If using a device without a PIN, one may need to manually trust the device before it can reconnect successfully. Enter ~trust MAC_address~ to do so.
8. Enter ~connect MAC_address~ to establish a connection.

** Troubleshooting
If blocked by =rfkill= then unlock it.


* Notification
[[https://wiki.archlinux.org/title/Dunst][Dunst]] is a lightweight replacement for the notification-daemons:
#+begin_src shell
  sudo pacman -S dunst libnotify
#+end_src

To use Dunst, the configuration file =.dotfiles/.config/dunst/dunstrc= must be placed or symlinked to =~/.config/dunst/dunstrc=.
Next, the =/usr/bin/dunst= should be launched, so make sure your window manager or desktop environment starts it at startup/login.

* TODO Sound
:LOGBOOK:
- State "TODO"       from              [2024-01-01 Mon 11:29] \\
  Rephrase
:END:
The Arch sound system consists of several levels:
1. Drivers and interface – hardware support and control
2. Usermode API (libraries) – utilized and required by applications
3. Usermode sound servers (optional) – best for the complex desktop, needed for multiple simultaneous audio applications, and vital for more advanced capabilities e.g. pro audio
4. Sound frameworks (optional) – higher-level application environments not involving server processes

A default Arch installation already includes the kernel sound system (ALSA).  ALSA — The default Linux kernel component providing device drivers and lowest-level support for audio hardware.
Which means it allow to read and write from audio devices/sound cards.

Source: https://wiki.archlinux.org/title/sound_system

=amixer= - command-line mixer for ALSA soundcard driver

Some application can record or output to directly to ALSA audio devices (sound card or microphone). This could be problematic because some audio devices not allow multiplexing so if a program is using the device others cannot use it at the same time. But some devices allow harware mixing which means two or many program transmet audio steam at the same time to audio device which will mix it into single output and send to for example speakers.

So as a solution to multiplexing and many other limitation sound server is created. 

PulseAudio is a abstracted layer above ALSA which act as server which takes audio from programs which are considerd as clients and gives to ALSA (driver) then ALSA to sound card.

We also have [[https://wiki.archlinux.org/title/JACK_Audio_Connection_Kit][Jack]] -  a professional sound server daemon that provides real-time, low-latency connections for both audio and MIDI data between applications that implement its API.

PipeWire is a replacement for PulseAudio and JACK.
It aims to offer capture and playback for both audio and video with minimal latency and support for PulseAudio, JACK, ALSA and GStreamer-based applications. 

** PulseAudio
PulseAudio is a general purpose sound server intended to run as a middleware between your applications and your hardware devices, either using ALSA or OSS.

Note: Some confusion may occur between ALSA and PulseAudio. ALSA includes a Linux kernel component with sound card drivers, as well as a userspace component, libasound.[1] PulseAudio builds only on the kernel component, but offers compatibility with libasound through pulseaudio-alsa.[2]
#+begin_src shell
  sudo pacman -S pulseaudio pulseaudio-bluetooth 
#+end_src
- =pulseaudio-alsa= for PulseAudio to manage ALSA as well, see [[https://wiki.archlinux.org/title/PulseAudio#ALSA][#ALSA]].
- =pulseaudio-bluetooth= for bluetooth support (Bluez), see [[https://wiki.archlinux.org/title/Bluetooth_headset][bluetooth headset]] page.


- =pactl= - Control a running PulseAudio sound server
  - pactl can be used to issue control commands to the PulseAudio sound server.
  - pactl only exposes a subset of the available operations. For the full set use the =pacmd=.

There are a number of front-ends available for controlling the PulseAudio daemon:
Console:
#+begin_src shell
  sudo pacman -S pamixer
#+end_src
Controls the volume levels of Pulseaudio sinks and sources.

Graphical:
#+begin_src shell
  sudo pacman -S pavucontrol
#+end_src
Simple GTK volume control tool ("mixer") for PulseAudio.

*** References
- [[https://wiki.archlinux.org/title/PulseAudio][PulseAudio]]

** PipeWire
PipeWire is a audio and video server that replaces PulseAudio, offer capture and playback for both audio and video with minimal latency and support for PulseAudio, JACK, ALSA and GStreamer-based applications:
#+begin_src shell
  sudo pacman -S pipewire 
#+end_src
- Install =lib32-pipewire= [fn:1] for multilib support. 

Like JACK, PipeWire implements no connection logic internally. The burden of watching for new streams and connect them to the appropriate output device or application is left to an external component known as a session manager:
#+begin_src shell
  sudo pacman -S wireplumber
#+end_src

Install the following to use PipeWire as audio server:
#+begin_src shell
  sudo pacman -S pipewire-alsa pipewire-pulse pipewire-jack 
#+end_src
- Install =pipewire-alsa= (and remove =pulseaudio-alsa= if it was installed) to route all applications using the ALSA API through PipeWire. 
- Replaces the =pulseaudio= and =pulseaudio-bluetooth=. Reboot, re-login or stop =pulseaudio.service= and start the =pipewire-pulse.service= user unit to see the effect.
  To check the good fuction of the service run the command ~pactl info~ and check for string "Server Name: PulseAudio (on PipeWire x.y.z)" in the output.
- The =pipewire-jack= for JACK support. There is also =lib32-pipewire-jack= for multilib support.

*** Bluetooth devices
PipeWire can also handles Bluetooth audio devices if the =pipewire-audio= package is installed
#+begin_src shell
  sudo pacman -S pipewire-audio
#+end_src

*** TODO Patchbay
:LOGBOOK:
- State "TODO"       from              [2024-01-01 Mon 19:48] \\
  Don't know whether it works with audio and video
  wathch the yt video
:END:
We could also install patchbay audio to redirect a audio stream to audio device or application:
#+begin_src shell
  sudo pacman -S qpwgraph
#+end_src

*** References
- [[https://wiki.archlinux.org/title/PipeWire][PipeWire]]

* Footnotes
[fn:1] Enable the multilib repository in pacman.conf to install 32-bit binaries.
