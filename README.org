To find out the default app for a particular type of file

> xdg-mime query filetype Documents/test.pdf

    application/pdf

To find out the mime for the extension

> xdg-mime query default application/pdf

    okularApplication_pdf.desktop

to set default app for an mimetype

> xdg-mime default zathura.desktop application/pdf
to test if applied successfully

> xdg-open test.md



Make zathura the default pdf viewer

Ensures, for example, that xdg-open(1) will open pdf files with zathura.

First, ensure a desktop entry for zathura exists at /usr/share/applications/org.pwmt.zathura.desktop. If it does not, download the desktop entry from from the zathura repo to /usr/share/applications/org.pwmt.zathura.desktop.

Then, set zathura as default using xdg-mime(1)

$ xdg-mime default org.pwmt.zathura.desktop application/pdf



________________________________
Emacs :
To find unbalanced parenthesis
run check-parens 

* My addition to .bashrc
- ~extract~ command (defined in =.bashrc=) extracts pages from a given PDF files.
- The script [[file:.local/bin/shortcuts][shortcuts]] will generate a file =$HOME/.config/shell/shortcutrc= (sourced by =.bashrc=) with aliases based on [[file:.config/shell/bm-files][bm-files]] and [[file:.config/shell/bm-files][bm-dirs]] files. This allows to use only one or some letters to move between folder or open a file.

* Program I Use
- =Pandoc= - A universal document converter.
- =pdftk= - Extract pages from PDF files
- =zbarimg= - Scan and decode bar codes from image file.

* Archive
The files mentioned below can be deleted without any side effects, they are only perserved as referened for future use: 
- Configuration files of =Xmodmap= and =Xbindkeys= have been archived into =.config= directory respectively.

* Sound
The Arch sound system is organized into different layers:
1. Drivers and interface – Hardware support and control, providing device drivers for audio hardware.
2. Usermode API (libraries) – Applications interact with this layer using libraries that offer a way to access sound-related functions.
3. Usermode sound servers (optional) – These servers, if used, enhance audio capabilities, especially in complex desktops with multiple simultaneous audio applications.
4. Sound frameworks (optional) – Optional frameworks offer a more abstract interface for developers working on audio-related applications, without relying on server processes.

A default Arch installation already includes the kernel sound system (ALSA).  ALSA — The default Linux kernel component providing device drivers and lowest-level support for audio hardware.
Which means it allow to read and write from audio devices/sound cards.

=amixer= - command-line mixer for ALSA soundcard driver.

Source: https://wiki.archlinux.org/title/sound_system

** PulseAudio
Certain applications have the capability to directly record from or output to ALSA audio devices, such as sound cards or microphones. However, this can pose issues because some audio devices don't support multiplexing, preventing multiple programs from using the device simultaneously. On the other hand, devices with hardware mixing can handle multiple audio streams concurrently, mixing them into a single output and send to devices like speakers.

To address multiplexing and other limitations, sound servers are created. One such example is =PulseAudio=, which serves as an abstracted layer above ALSA. PulseAudio acts as a server, taking audio from programs considered as clients, delivering it to ALSA (driver), and from there to the sound card.

Another noteworthy sound server is =Jack=, designed for professional use. Jack functions as a sound server daemon, providing real-time, low-latency connections for both audio and MIDI data between applications following its API.

/Note: Some confusion may occur between ALSA and PulseAudio. ALSA includes a Linux kernel component with sound card drivers, as well as a userspace component, =libasound=. PulseAudio builds only on the kernel component, but offers compatibility with libasound through =pulseaudio-alsa=./

#+begin_src shell
  sudo pacman -S pulseaudio pulseaudio-bluetooth 
#+end_src
- =pulseaudio-alsa= for PulseAudio to manage ALSA as well, see [[https://wiki.archlinux.org/title/PulseAudio#ALSA][#ALSA]].
- =pulseaudio-bluetooth= for bluetooth support (Bluez), see [[https://wiki.archlinux.org/title/Bluetooth_headset][bluetooth headset]] page.

The =pactl= command can control the running PulseAudio sound server, offering only a subset of operations; for the complete set, use =pacmd=

Various front-ends, including =pamixer= for console-based volume control and =pavucontrol= for graphical interface, are available for controlling the PulseAudio daemon on Arch Linux.

Source : https://wiki.archlinux.org/title/PulseAudio

** PipeWire
PipeWire is introduced as a replacement for both PulseAudio and JACK, aiming to provide minimal-latency capture and playback for both audio and video. It is a audio and video server that support PulseAudio, JACK, ALSA and GStreamer-based applications, offering a versatile solution for a wide range of audio and video requirements.

#+begin_src shell
  sudo pacman -S pipewire 
#+end_src
- Install =lib32-pipewire= [fn:1] for multilib support. 

Like JACK, PipeWire implements no connection logic internally. The burden of watching for new streams and connect them to the appropriate output device or application is left to an external component known as a session manager:
#+begin_src shell
  sudo pacman -S wireplumber
#+end_src

To use PipeWire as an audio server, install the following packages:
#+begin_src shell
  sudo pacman -S pipewire-alsa pipewire-pulse pipewire-jack 
#+end_src
- =pipewire-alsa= (and remove =pulseaudio-alsa= if it was installed) routes all applications using the ALSA API through PipeWire. 
- =pipewire-pulse= replaces the =pulseaudio= and =pulseaudio-bluetooth=. Reboot, re-login or stop =pulseaudio.service= and start the =pipewire-pulse.service= user unit to see the effect.
  /To check the good fuction of the service run the command ~pactl info~ and check for string "Server Name: PulseAudio (on PipeWire x.y.z)" in the output./
- The =pipewire-jack= for JACK support.
  /There is also =lib32-pipewire-jack= for multilib support./

*** Bluetooth devices
PipeWire can also handle Bluetooth audio devices by installing the =pipewire-audio= package:
#+begin_src shell
  sudo pacman -S pipewire-audio
#+end_src

*** Patchbay
To redirect an audio stream to an audio device or application using PipeWire, you can install the =pipewire-pulse= package, which includes the patchbay audio functionality:
#+begin_src shell
  sudo pacman -S qpwgraph
#+end_src

*** References
- [[https://wiki.archlinux.org/title/PipeWire][PipeWire]]

* Bluetooth
=Bluetooth= is a standard for the short-range wireless interconnection of cellular phones, computers, and other electronic devices. In Linux, the canonical implementation of the Bluetooth protocol stack is =BlueZ=.

1. Install the =bluez= package, providing the Bluetooth protocol stack.
2. Install the =bluez-utils= package, providing the bluetoothctl utility. Alternatively install =bluez-utils-compat=  (AUR Package) to additionally have the deprecated BlueZ tools.
3. The generic Bluetooth driver is the =btusb= kernel module. Check whether that module is loaded. If it is not, then load the module.
4. Start/enable =bluetooth.service=.

#+begin_src shell
  sudo pacman -S bluez bluez-utils
#+end_src

By default the Bluetooth daemon will only give out =bnep0= devices to users that are a member of the =lp= group. Make sure to add your user to that group if you intend to connect to a Bluetooth tether. You can change the group that is required in the file =/usr/share/dbus-1/system.d/bluetooth.conf=: 
#+begin_src shell
  usermod -aG lp $(whoami)
#+end_src

** Pair Bluetooth Devices
Start the =bluetoothctl= interactive command:
1. (optional) Select a default controller with ~select MAC_address~.
2. (optional) Enter ~power on~ to turn on the controller on. It is on by default
3. Enter ~devices~ to get the MAC address of the device with which to pair.
   3.1. (optional) Enter device discovery mode with ~scan on~ command if device is not yet on the above list.
   3.2. Turn the agent on with  ~agent on~ or choose a specific agent: if you press tab twice after agent you should see a list of available agents. 
   A bluetooth agent is what manages the Bluetooth 'pairing code'. It can either respond to a 'pairing code' coming in, or can send one out. The default-agent should be appropriate in most cases.
6. Enter ~pair MAC_address~ to do the pairing.
7. If using a device without a PIN, one may need to manually trust the device before it can reconnect successfully. Enter ~trust MAC_address~ to do so.
8. Enter ~connect MAC_address~ to establish a connection.

** Troubleshooting
If blocked by =rfkill= then unlock it.

* Notification
[[https://wiki.archlinux.org/title/Dunst][Dunst]] is a lightweight replacement for the notification-daemons:
#+begin_src shell
  sudo pacman -S dunst libnotify
#+end_src

To use Dunst, the configuration file =.dotfiles/.config/dunst/dunstrc= must be placed or symlinked to =~/.config/dunst/dunstrc=.
Next, the =/usr/bin/dunst= should be launched, so make sure your window manager or desktop environment starts it at startup/login.

* FIXME [0/3]
** TODO Write a readme for Dotrice
:LOGBOOK:
- State "TODO"       from              [2023-10-29 dim. 22:41] \\
  Write a proper READEME as Luke Smith
:END:

** TODO Shortcuts to Implement
:LOGBOOK:
- State "TODO"       from              [2024-01-16 Tue 21:06]
:END:
Super + m music player
Super + i htop
Super +r ranger
super f9 mount disk with dmenu
super f10 unmount
super  f3 select a multi screen 
(gui program arandr)
super printsrc record screen
super u dropdown tmux terminal

** TODO Create a script
:LOGBOOK:
- State "TODO"       from              [2024-01-16 Tue 21:06]
:END:
- It will create directory:
~/.config/shell
~/config/emacs

- Which link var.el to ~/config/emacs if exists.
- Install =imagemagick= for Ranger to rotate an image
